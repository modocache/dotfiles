import os
import ycm_core


HEADER_EXTENSIONS = ['.h', '.hxx', '.hpp', '.hh']
SOURCE_EXTENSIONS = ['.cpp', '.cxx', '.cc', '.c', '.m', '.mm']


def is_header(filename):
  return os.path.splitext(filename)[-1] in HEADER_EXTENSIONS


def absolutify_path(path, working_directory):
    if os.path.isabs(path):
        return path
    else:
        return os.path.join(working_directory, path)


def absolutify_args(args, working_directory):
    absolutified_args = []

    make_next_absolute = False
    for arg in args:
        # The arguments could be something like:
        # a) [..., '-isystem' '../some/path', ...], or
        # b) [..., '-I../some/path', ...]

        if make_next_absolute:
            make_next_absolute = False
            arg = absolutify_path(arg, working_directory)

        for option in ['-isystem', '-I', '-iquote', '--sysroot=']:
            if arg == option:
                # This is case (a) above: we don't modify the current argument,
                # but we remember that the next argument should be made
                # absolute.
                make_next_absolute = True
                break
            elif arg.startswith(option):
                # This is case (b) above: we split the argument, absolutify it,
                # then put it back together.
                path = arg[len(option):]
                arg = option + absolutify_path(path, working_directory)
                break

        absolutified_args.append(arg)

    return absolutified_args


def get_compilation_info_for_file(filename, compile_commands):
    if is_header(filename):
        # The compilation_commands.json file generated by CMake does not have
        # entries for header files. So we do our best by finding arguments for a
        # corresponding source file, if any. If one exists, the arguments for
        # that file are used as an approximation.
        basename = os.path.splitext(filename)[0]
        for extension in SOURCE_EXTENSIONS:
            src_file = basename + extension
            if os.path.exists(src_file):
                info = compile_commands.GetCompilationInfoForFile(src_file)
                if info.compiler_flags_:
                    return info
        # Couldn't find a corresponding source file, so just return nothing.
        return None

    return compile_commands.GetCompilationInfoForFile(filename)


COMPILE_COMMANDS_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                                                    'build')
if os.path.exists(COMPILE_COMMANDS_DIR):
    COMPILE_COMMANDS = ycm_core.CompilationDatabase(COMPILE_COMMANDS_DIR)
else:
    COMPILE_COMMANDS = None


def FlagsForFile(filename, **kwargs):
    compile_commands = COMPILE_COMMANDS
    if not compile_commands:
        return {
            'flags': [],
            'do_cache': False
        }

    compilation_info = get_compilation_info_for_file(filename,
                                                     compile_commands)
    if not compilation_info:
        return None

    flags = absolutify_args(compilation_info.compiler_flags_,
                            compilation_info.compiler_working_dir_)

    return {
        'flags': flags,
        'do_cache': True
    }
